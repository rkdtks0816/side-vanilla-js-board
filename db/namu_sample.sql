-- --------------------------------------------------------
-- 호스트:                          125.191.175.102
-- 서버 버전:                        10.10.2-MariaDB-1:10.10.2+maria~ubu2204 - mariadb.org binary distribution
-- 서버 OS:                        debian-linux-gnu
-- HeidiSQL 버전:                  11.3.0.6295
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8 */;
/*!50503 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


-- db_song 데이터베이스 구조 내보내기
CREATE DATABASE IF NOT EXISTS `db_song` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */;
USE `db_song`;

-- 테이블 db_song.CommentTable 구조 내보내기
CREATE TABLE IF NOT EXISTS `CommentTable` (
  `NickName` varchar(50) DEFAULT NULL,
  `PostCreatDatetime` datetime DEFAULT NULL,
  `CommentNickName` varchar(50) DEFAULT NULL,
  `CommentContent` longtext DEFAULT NULL,
  `CommentCreatDatetime` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- 테이블 데이터 db_song.CommentTable:~2 rows (대략적) 내보내기
/*!40000 ALTER TABLE `CommentTable` DISABLE KEYS */;
INSERT INTO `CommentTable` (`NickName`, `PostCreatDatetime`, `CommentNickName`, `CommentContent`, `CommentCreatDatetime`) VALUES
	('프론트엔드', '2023-01-03 09:23:05', '백엔드', '백과 프론트의 차이를 잘 알수있네요', '2023-01-03 09:24:00'),
	('프론트엔드', '2023-01-03 09:23:05', '클라우드', '클라우드는 백인가요?', '2023-01-03 09:24:48');
/*!40000 ALTER TABLE `CommentTable` ENABLE KEYS */;

-- 테이블 db_song.PostTable 구조 내보내기
CREATE TABLE IF NOT EXISTS `PostTable` (
  `NickName` varchar(50) DEFAULT NULL,
  `UserID` varchar(50) DEFAULT NULL,
  `PostTitle` text DEFAULT NULL,
  `PostContent` longtext DEFAULT NULL,
  `PostCreatDatetime` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- 테이블 데이터 db_song.PostTable:~11 rows (대략적) 내보내기
/*!40000 ALTER TABLE `PostTable` DISABLE KEYS */;
INSERT INTO `PostTable` (`NickName`, `UserID`, `PostTitle`, `PostContent`, `PostCreatDatetime`) VALUES
	('클라우드', 'cd', '클라우드란 무엇입니까?', '"클라우드"는 인터넷을 통해 액세스할 수 있는 서버와 이러한 서버에서 작동하는 소프트웨어와 데이터베이스를 의미합니다. 클라우드 서버는 전 세계 데이터 센터에 위치합니다. 사용자와 기업은 클라우드 컴퓨팅을 사용하면 직접 물리적 서버를 관리하거나 자체 서버에서 소프트웨어 응용 프로그램을 실행하지 않아도 됩니다.\n\n클라우드를 통해 사용자는 거의 모든 장치에서 동일한 파일과 애플리케이션을 액세스할 수 있습니다. 컴퓨팅과 저장이 사용자 장치에서 로컬로 실행되지 않고 데이터 센터의 서버에서 이루어지기 때문입니다. 따라서 사용자는 이전 휴대 전화가 고장난 후 새로운 휴대 전화에서 Instagram 계정에 로그인해도 모든 사진, 동영상, 대화 이력이 그대로 계정에 유지되어 있는 것을 볼 수 있습니다. Gmail이나 Microsoft Office 365 같은 클라우드 이메일 공급자와 Dropbox나 Google Drive 같은 클라우드 스토리지 공급자와 동일한 방식으로 작동합니다.\n\n기업의 경우 클라우드 컴퓨팅으로 전환하면 IT 비용과 간접비가 절감됩니다. 예를 들어, 자체 서버를 더 이상 업데이트하고 유지하지 않아도 됩니다. 클라우드 업체가 대신 처리하기 때문입니다. 자체 내부 인프라를 사용할 수 없지만 클라우드를 통해 저렴한 가격으로 인프라 필요를 아웃소싱할 수 있는 작은 기업에 특히 효과적입니다. 기업은 또한 클라우드를 통해 더욱 간편하게 전 세계에서 활동할 수 있습니다. 직원과 고객이 어디서나 동일한 파일과 애플리케이션을 액세스할 수 있기 때문입니다.', '2023-01-03 09:15:54'),
	('클라우드', 'cd', '클라우드 컴퓨팅은 어떻게 작동합니까?', '가상화라는 기술 때문에 클라우드 컴퓨팅이 가능합니다. 가상화로 자체 하드웨어를 가진 실제 컴퓨터처럼 작동할 수 있는 시뮬레이션된 디지털 전용 "가상" 컴퓨터를 만들 수 있습니다. 이러한 컴퓨터를 전문 용어로 가상 머신이라 합니다. 올바로 실행되면, 동일한 호스팅 머신 상의 가상 머신은 서로 샌드박스되어 전혀 상호 작용하지 않고, 한 가상 머신의 파일과 응용 프로그램은 동일한 물리적 머신에 있어도 다른 가상 머신이 볼 수 없습니다.\n\n가상 머신도 자신을 호스팅하는 하드웨어를 더욱 효율적으로 사용합니다. 많은 가상 머신을 동시에 실행하면 한 서버에서 여러 서버를 실행하고 데이터 센터가 모든 데이터 센터가 되어 여러 조직에 서비스를 제공할 수 있습니다. 따라서 클라우드 공급자는 다른 방식을 사용하면 불가능하지만 서버 사용을 동시에 훨씬 많은 고객에게 제공할 수 있고 더불어 비용도 절감할 수 있습니다.\n\n개별 서버가 멈추더라도 일반적으로 클라우드 서버는 언제나 온라인 상태와 가용성을 유지해야 합니다. 일반적으로 클라우드 업체는 여러 머신과 여러 지역에 서비스를 백업합니다.\n\n사용자는 사용하는 장치에 관계없이 브라우저나 앱을 사용하여 수많은 상호 연결된 네트워크, 즉 인터넷을 통해 클라우드에 연결합니다.', '2023-01-03 09:16:32'),
	('클라우드', 'cd', '클라우드 컴퓨팅의 대표적인 서비스 모델은 어떻게 됩니까?', 'SaaS(Software-as-a-Service): 사용자가 장치에 애플리케이션을 설치하는 대신 SaaS 애플리케이션이 클라우드 서버에 호스팅되고 사용자는 인터넷을 통해 애플리케이션에 액세스합니다. SaaS는 집을 빌리는 것과 같습니다. 임대인이 집을 유지하지만 임차인이 집을 소유한 것처럼 집을 주로 사용합니다. SaaS 애플리케이션의 예에는 Salesforce, MailChimp, Slack이 있습니다.\n\nPaaS(Platform-as-a-Service): 이 모델에서 기업은 호스팅된 애플리케이션에 비용을 지불하는 대신 자체 애플리케이션을 구축하는 데 필요한 것에 비용을 지불합니다. PaaS 업체는 개발 도구, 인프라, 운영 체제를 포함한 애플리케이션 구축에 필요한 모든 것을 인터넷을 통해 제공합니다. PaaS는 집을 임대하는 대신 집을 짓는 데 필요한 모든 도구와 장비를 빌리는 것과 비슷합니다. PaaS의 예에는 Heroku와 Microsoft Azure가 있습니다.\n\nIaaS(Infrastructure-as-a-Service): 이 모델에서 기업은 클라우드 공급자로부터 필요한 서버와 저장소를 임대합니다. 그리고 클라우드 인프라로 자체 응용 프로그램을 구축합니다. IaaS는 기업이 원하는 건물을 지을 수 있는 토지를 임대하는 것과 같습니다. 하지만 기업은 직접 건설 장비와 재료를 마련해야 합니다. IaaS 공급자에는 DigitalOcean, Google Compute Engine, OpenStack이 있습니다.\n\n과거에는 SaaS, PaaS, IaaS가 클라우드 컴퓨팅의 3대 모델이었으며 모든 클라우드 서비스는 이들 범주 중 하나에 속했습니다. 하지만 최근에 네 번째 모델이 나타났습니다.\n\nFaaS(Function-as-a-Service): FaaS는 서버리스 컴퓨팅이라고도 하며 클라우드 응용 프로그램을 필요할 때만 실행되는 더 작은 구성 요소로 나눕니다. 한 번에 집을 조금씩만 임대할 수 있다고 생각해보세요. 예를 들어, 임차인은 식사할 때 식당에 대해, 잘 때 침실에 대해, TV를 볼 때 거실에 대해 비용을 지불하고 이러한 방을 사용할 때 임대료를 지불하지 않아도 됩니다.\n\nFaaS 즉 서버리스 응용 프로그램은 다른 클라우드 컴퓨팅 모델과 마찬가지로 여전히 서버에서 실행됩니다. "서버리스"라 불리는 것은 전용 머신에서 실행되지 않고 응용 프로그램을 구축한 기업이 서버를 관리하지 않아도 되기 때문입니다.\n\n또한 서버리스 기능은 응용 프로그램 사용자가 증가하면 확장되거나 복제됩니다. 저녁 시간에 손님이 많아지면 필요에 따라 식당을 늘릴 수 있는 임대인을 생각해 보면 됩니다. 서버리스 컴퓨팅(FaaS)에 대해 자세히 알아보세요.', '2023-01-03 09:16:50'),
	('클라우드', 'cd', '클라우드 배포에는 어떠한 유형이 있습니까?', '클라우드를 통해 서비스가 제공되는 방식을 정의한 위 모델과 달리, 클라우드 배포 유형은 클라우드 서버의 위치와 서버 관리자와 관계 있습니다.\n\n가장 일반적인 클라우드 배포:\n\n프라이빗 클라우드: 프라이빗 클라우드는 서버, 데이터 센터 또는 분산 네트워크를 모두 한 조직만이 사용할 수 있는 형태입니다.\n퍼블릭 클라우드: 퍼블릭 클라우드는 외부 벤더가 운영하는 클라우드 서비스로, 서버는 하나 또는 다수의 데이터 센터에 있을 수 있습니다. 퍼블릭 클라우드는 프라이빗 클라우드와 달리 다수의 조직에서 공유합니다. 가상 머신을 이용하면, 여러 회사에서 개별 서버를 공유할 수 있으며, 여러 회사에서 동일한 물리적 서버 내의 서버 공간을 임대하기 때문에 이를 "다중 테넌트(임대인)"라고 부릅니다.\n하이브리드 클라우드: 하이브리드 클라우드 배포는 퍼블릭 클라우드와 프라이빗 클라우드를 결합하며 온프레미스 레거시 서버도 포함할 수 있습니다. 조직은 서비스에 따라 프라이빗 클라우드와 퍼블릭 클라우드를 사용하거나 퍼블릭 클라우드를 프라이빗 클라우드의 백업으로 사용할 수 있습니다.\n멀티클라우드: 멀티클라우드는 다수의 퍼블릭 클라우드를 사용하는 클라우드 배포 유형입니다. 다시 말해, 멀티클라우드 배포를 사용하는 조직은 여러 외부 업체로부터 가상 서버와 서비스를 대여합니다. 앞서 사용한 비유를 이용하면 다수의 토지 소유주로부터 인접한 대지 여러 개를 빌리는 것과 같습니다. 멀티클라우드 배포도 하이브리드 클라우드가 될 수 있으며 그 반대도 가능합니다.', '2023-01-03 09:17:03'),
	('백엔드', 'bk', '백엔드 개요', '백엔드는 일반 사용자 눈에 보이지 않는 서버에서 작용하는 기술을 다루는 직군으로, UI나 GUI로 구성된 화면의 통신 및 요청에 대하여 인터페이스나 데이터베이스 등을 통해 시스템 구성 실체에 접근한다. 후위 처리라고도 부른다. 프런트엔드와 함께 연동되어, 사용자와 접촉하지 않고 기술적인 부분을 처리한다. 프런트엔드가 가능하도록 데이터를 저장하고 서버를 구축하는 일을 맡는다.[1] 백엔드는 서버와 응용 프로그램, 데이터베이스로 구성되어 있으므로, 백엔드 개발자는 이 구성요소들이 잘 작동할 수 있도록 기술의 개발과 유지보수를 진행한다.', '2023-01-03 09:18:51'),
	('백엔드', 'bk', '백엔드 역사', '2000년대 닷컴 붐이 일어나 많은 회사가 생기면서 웹 시스템과 관련된 기술들이 등장하고 발전했다. 이때의 웹 서버는 단순히 웹 브라우저가 요청하는 해당 페이지를 보내주는 일을 했다. 그러나 시간이 흘러 자연스럽게 사용자와 웹페이지에서의 동적인 상호작용이 중요해지자, 단순했던 웹 서비스들이 조금씩 복잡해지고 자바스크립트의 역할이 증가하는 등 사용자 인터랙션이 중요해졌다. 웹서버가 HTML뿐만 아니라 자바스크립트 코드도 웹 브라우저에 전송하면 웹브라우저는 서버에서 전송받은 자바스크립트 코드를 실행하여 사용자에게 동적인 기능을 제공한다. 이를 통해 전체 페이지를 불러오지 않아도 사용자의 요구를 동적으로 처리하고 새로운 데이터를 제공할 수 있게 되었다. 자바스크립트가 HTML 파일의 일부분이라 웹사이트가 부분적으로 동적이었던 과거와 달리, 자바스크립트가 HTML의 생성부터 사이트에 관한 전반적인 부분을 구현하게 되었다. 현대에는 웹 시스템의 규모가 커지고 처리해야 하는 요청의 양이 기하학적으로 증가하여, API 시스템들이 너무 방대해지고 있다. 따라서 이러한 복잡한 문제들을 해결하기 위해 MSA 같은 새로운 아키텍처 개념이 발전하고 덕분에 API 서버가 더욱 세분되고 규모가 커졌다. 또, 서버에서 분석해야 할 데이터가 증가하여 많은 백엔드 시스템에 빅데이터 분석 시스템이 도입되었다. 현대의 백엔드 개발 영역은 일반적인 백엔드 API 시스템, 데이터 파이프라인 시스템, 머신러닝 시스템, 빅데이터 분석 시스템 등을 예로 들 수 있고, 비실시간 대규모 데이터 수집 및 분석 시스템과 머신러닝 시스템까지 개발 범위가 넓어지고 있다.[3]', '2023-01-03 09:19:15'),
	('백엔드', 'bk', '백엔드 개발', '백엔드 개발은 사용자 인터페이스를 만들어내는 코드 작성과 관련 없는 전반적인 모든 개발을 일컫는다. 사용자의 육안에 들어오는 프런트엔드가 제대로 잘 작동할 수 있도록 최종 사용자의 눈에 보이지 않는 뒷단에서 백엔드 코드가 작성하는데, 세상에 존재하는 프로그래밍 코드의 대부분은 백엔드에서 작성되는 코드라고 할 수 있다. 백엔드 개발자가 하는 일은 다음과 같다.\n\n비즈니스 이해 관계자와 소통하며 구체적인 요구 사항을 파악하고, 요구사항을 기술적인 내용으로 변환한다.\n기술설계를 위한 가장 효율적인 해결책을 고안 및 제시한 후, 개발자의 기술을 사용하여 모듈화가 가능한 코드로 웹 응용 프로그램을 개발한다.\n프런트엔드 개발자보다 알고리즘을 적용하고 문제를 해결하는 데 더 많은 시간을 사용한다.\n전반적으로 프런트엔드, 백엔드의 완전한 분리 구조를 지향하는 업무 스타일의 개발을 지향하며, 주로 백엔드의 데이터베이스와 API 서버 개발을 맡는다. 이와 다른 방식의 업무 스타일 직군으로는 웹 퍼블리셔와 서버 개발자의 업무 분리 방식이 있다. 이 경우는 주로 서버 사이드가 클라이언트를 감싸는 방식이고, 전반적인 비즈니스 로직은 개발자가 맡는다. 뷰단은 화면단보다 API 개발이 더 주가 되며, 프런트엔트에서 전달한 데이터를 가지고 데이터베이스 입출력, 포맷, 다양한 비즈니스 프로세스를 프로그래밍 코드로 구현하는 역할을 해야 한다. 여기서 백엔드와 프런트엔드의 기술을 모두 다룰 줄 아는 개발자가 풀 스택 개발자이다.[4] 서버 개발에는 기술 면에서 프로그래밍, 데이터베이스, 웹 서버, 네트워크, 인프라 등에 대한 지식과 기술이 필요하다. 자신이 쓰는 기술 스택에 맞는 서버 측의 언어를 능숙하게 사용해야만 하며, 응용 프로그램을 제작하기 위해 PHP, 루비, 파이썬, 자바 등의 언어가 사용된다. 프런트엔드 개발자가 HTML, CSS, 자바스크립트에 집중할 때 백엔드 개발자는 PHP 웹 구조, 루비 온 레일스, ASP.NET MVC를 비롯한 서버 측 웹 개발 구조에 집중한다. 또한, 데이터 검색, 저장, 변경 후에도 프론트엔드 코드로 사용자에게 다시 제공하기 위해 마이에스큐엘, 오라클, SQL Server 등의 기술이 사용된다.[5]', '2023-01-03 09:19:54'),
	('프론트엔드', 'ft', '프론트엔드 개요', '프런트엔드는 사용자 인터페이스(UI)를 가지고 동작하며 프로그램 인터페이스와 서비스의 최초 사용자와 관련된 특성을 나타내는 데 사용되는 용어이다. 여기서 “사용자”란 사람 또는 프로그램이 될 수 있다. 프런트엔드 응용프로그램은 사용자들과 직접 상호작용을 하는 프로그램이다. 프런트엔드 응용프로그램은 사용자와 직접 인터페이스할 수 있으며, 요구된 데이터를 얻거나 요구된 서비스를 수행하기 위하여 원격지의 다른 컴퓨터에 위치한 백엔드 프로그램으로 요구를 전달한다. 클라이언트/서버 컴퓨팅 모델과 비교한다면, 프런트엔드는 클라이언트로, 백엔드는 서버로 이해할 수 있다.[1]', '2023-01-03 09:21:37'),
	('프론트엔드', 'ft', '프론트엔드 등장 배경', '4차 산업혁명으로 인해 사람들의 업무의 패러다임이 급격히 변화되고 있다. 그동안 사람들이 직접 노동력을 들여서 단순 반복 처리하던 일들을 이제는 컴퓨터가 대신 처리한다. 사람이 하는 게 당연시되던 일들을 이젠 컴퓨터가 대신 처리하게 되면서 앞으로 사라질 직군이 많이 셍길 수밖에 없고 또 사라지는 직군만큼 새로운 직군들이 많이 생겨나게 될 것이다. 프런트엔드 개발자도 위와 비슷한 맥락에서 새롭게 주목받고 있는 직군에 속한다.[2]\n\n초창기 웹 프런트엔드 개발은 사용자 인터페이스를 개발하는 영역이었다. 그런데 지금의 프런트엔드는 상황이 많이 달라졌다. 초창기 프런트엔드는 이미지나 와이어 프레임 등을 이용해 웹페이지를 그리거나 만들거나, 콘텐츠를 정의하기 위해 HTML과 CSS를 작성하는 것이었다. 하지만 최근 프런트엔드는 사용자 경험(UX, User Experience)을 고려해 디자인과 엔지니어링의 정의부터 웹 표준, 웹 콘텐츠 접근성, 다양한 디바이스 고려, 보안 측면 대응까지 다양한 요구를 만족해야 하는 수준까지 왔다.[3]\n\n초창기엔 대부분의 웹 개발자들이 웹사이트는 물론이고, 백엔드 웹 애플리케이션까지 개발해야했었다. 프런트엔드에 앵귤러(Angular), 리액트(React), 뷰(Vue)와 같은 최신 프레임워크가 도입되었고, 브라우저에서는 불가능하다고 생각되었던 수많은 기능을 지원하는 최신 브라우저가 등장했으며, 웹지엘(WebGl)과 같은 그래픽 엔진까지 나타나면서 개발자들은 이제 프런트엔드 개발에 좀 더 집중할 수 있게 되었다.[4]', '2023-01-03 09:22:04'),
	('프론트엔드', 'ft', '프론트엔드 특징', '웹 프런트엔드를 개발하기 위해서는 다양한 기술이 필요하다. 그 영역을 외관, 아키텍처, 적합성, 생태계, 언어, 프로토콜, 브라우저, 유아이 컴포넌트, 워크플로우 등으로 구분할 수 있다. 외관은 웹사이트에서 밖으로 보이는 부분으로 애니메이션, 타이포그래피, 시각화로 구분된다. 아키텍처는 프런트엔드 구조 및 설계 규칙 등으로 알고리즘, 디자인 패턴, 함수적 프로그래밍 등을 고려한다.[3]\n\n이중 언어 기술인 이 중 언어 기술인 HTML, CSS, 자바스크립트 세 가지가 가장 기본이 된다. HTML은 웹 페이지의 구조를, CSS는 웹의 스타일을 구성하며, 웹의 동적 기능은 자바스크립트가 담당한다.[3]\n\nHTML\nHyper Text와 Markup Language의 약자로서, 인터넷 웹사이트 등 하이퍼텍스트를 편집하기 위한 코딩 언어이다. 최초 제안자는 1980년 유럽 인자 물리학 연구소에서 연구 중이던 물리학자 팀 버너스-리(Tim Berners-Lee)이다. HTML은 문서의 글자색, 글자 모양, 글자 크기, 이미지 배치, 문서 이동 등등 이렇게 문서 작성에 관여되는 부분들을 정의하는 명령어로서 홈페이지를 작성하는 데 쓰인다. HTML은 정보를 불러오는 과정과 자신이 입력한 명령어에 대한 명령 입력과정에서 오류가 발생하는 경우가 종종 있어서 이를 보완하기 위해 자바스크립트, 에이잭스(AJAX) 같은 여러 가지 스크립트들과 같이 쓰일 수도 있다. 사람들이 편리하고 쉬운 이유로 많이 쓰기 때문에 "웹"으로 시작하는 직업들의 기초 상식이라고 볼 수 있다.[9]\nCSS\nCascading Style Sheets의 약자로서, 웹 문서의 색상, 폰트, 레이아웃 등을 표현하기 위해 사용하는 스타일 시트 언어이다. CSS는 1994년 하콤 비움 리(Håkon Wium Lie)가 발명했으며 W3C(World Wide Web Consortium)에서 관리하였다. CSS는 웹 페이지의 모양과 느낌을 처리하고 텍스트 색상, 글꼴 스타일, 문단간격, 열크기 및 배치 방법 등 여러 가지를 제어할 수 있다. CSS는 배우기 쉽고 이해하기 쉬우면서도 HTML 문서를 강력하게 제어할 수 있다. 보통 일반적으로 HTML과 XHTML에서 주로 쓰인다. HTML만으로 웹 페이지를 제작할 경우에는 HTML 요소의 세부적인 스타일들을 따로 일일이 지정해 주어야 하는데 이 작업은 매우 많은 시간이 걸려 완성한 후에도 스타일의 변경 및 유지 보수가 매우 힘든데 CSS를 사용하면 웹 페이지의 스타일을 편리하게 개발할 수 있다.[10]\n자바스크립트\n1995년 미국 넷스케이프(Netscape)의 브렌든 아이크(Brendan Eich)가 개발한 스크립트 프로그래밍 언어이다. 자바스크립트는 표준 HTML 문서 내에 삽입되어 사용되며, 인터랙티브한 웹 페이지를 만들 수 있게 한다. 자바스크립트의 장점은 다른 언어와 달리 컴파일 과정이 존재하지 않기 때문에 빠르게 스크립트 코드 작성과 실행이 가능하며 웹브라우저에서 동작하는 스크립트 언어이기 때문에 운영체제(OS)를 가리지 않고 프로그램의 실행이 가능한 것이다. 자바스크립트의 단점은 객체와 객체 함수가 제한적이어서 기능 또한 제한적이라는 점과 개발할 수 있는 도구가 적고 HTML 소스 코드 안에 포함되어 작성되기 때문에 소스 코드가 외부로 공개되서 보안상 취약점이 발생할 수 있다는 점이다.[11]', '2023-01-03 09:22:27'),
	('프론트엔드', 'ft', '프론트  백 차이점 ', '프런트엔드와 백엔드는 프로그램 인터페이스와 서비스의 최초 사용자와 관련된 특성을 나타내는 데 사용되는 용어로, 사람 또는 프로그램을 사용자라고 칭한다. 백엔드와 프런트엔드의 차이를 비교해보자면, 용어부터 일반적으로 프런트엔드와 백엔드는 각각 프로세스의 처음과 마지막 단계를 가리킨다. 클라이언트 서버 컴퓨팅 모델과 비교하자면 프런트엔드는 클라이언트에, 백엔드는 서버에 비유할 수 있다.[2]\n\n프런트엔드\n사용자로부터 다양한 형태의 입력을 받아 백엔드가 사용할 수 있는 규격을 따라 처리할 책임을 진다.\n하나 또는 하나 이상의 사용자와 직접 상호작용을 하는 프로그램이다.\n사용자와 직접 인터페이스 할 수 있고, 필요한 데이터를 얻거나 요구한 서비스를 수행하기 위해 다른 컴퓨터로 위치한 백엔드 프로그램으로 사용자의 요구를 전달한다.\n백엔드\n클라이언트와 직접 접촉하지 않고 프런트엔드 프로그램과 연동하여 기술적인 기능을 수행하는 프로그램\n백엔드 없이는 UI는 프로세스 형태로만 존재하며, 프런트엔드는 UI를 가지고 동작한다.\n대체로 요구 자원들과 가깝게 위치하거나 요구 자원들과 충분히 교신할 수 있는 능력을 갖추는 등 프런트 엔드 서비스를 뒤에서 전반적으로 지원하는 역할\n프런트엔드와 직접 상호작용할 수 있지만, 보통은 그사이에 또 다른 프로그램이 함께 위치하여 프런트엔드와 백엔드 간의 업무를 조정한다.\n프런트엔드가 가능하도록 데이터를 저장하고 서버를 구축하는 역할을 맡는다. 서버, 응용 프로그램, 데이터베이스로 구성되며, 백엔드 개발자는 이 구성요소들이 작동할 수 있도록 기술의 개발과 유지보수를 맡는다.', '2023-01-03 09:23:05');
/*!40000 ALTER TABLE `PostTable` ENABLE KEYS */;

-- 테이블 db_song.ReplyTable 구조 내보내기
CREATE TABLE IF NOT EXISTS `ReplyTable` (
  `NickName` varchar(50) DEFAULT NULL,
  `PostCreatDatetime` datetime DEFAULT NULL,
  `CommentNickName` varchar(50) DEFAULT NULL,
  `CommentCreatDatetime` datetime DEFAULT NULL,
  `ReplyNickName` varchar(50) DEFAULT NULL,
  `ReplyContent` longtext DEFAULT NULL,
  `ReplyCreatDatetime` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- 테이블 데이터 db_song.ReplyTable:~3 rows (대략적) 내보내기
/*!40000 ALTER TABLE `ReplyTable` DISABLE KEYS */;
INSERT INTO `ReplyTable` (`NickName`, `PostCreatDatetime`, `CommentNickName`, `CommentCreatDatetime`, `ReplyNickName`, `ReplyContent`, `ReplyCreatDatetime`) VALUES
	('프론트엔드', '2023-01-03 09:23:05', '백엔드', '2023-01-03 09:24:00', '클라우드', '공감합니다', '2023-01-03 09:24:58'),
	('프론트엔드', '2023-01-03 09:23:05', '클라우드', '2023-01-03 09:24:48', '프론트엔드', '백엔드 맞습니다!', '2023-01-03 09:26:08'),
	('프론트엔드', '2023-01-03 09:23:05', '클라우드', '2023-01-03 09:24:48', '클라우드', '감사합니다!', '2023-01-03 09:26:30');
/*!40000 ALTER TABLE `ReplyTable` ENABLE KEYS */;

-- 테이블 db_song.UserTable 구조 내보내기
CREATE TABLE IF NOT EXISTS `UserTable` (
  `UserName` varchar(50) DEFAULT NULL,
  `NickName` varchar(50) DEFAULT NULL,
  `UserID` varchar(50) DEFAULT NULL,
  `UserPassword` varchar(50) DEFAULT NULL,
  `UserEmail` varchar(50) DEFAULT NULL,
  `IdCreatDatetime` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- 테이블 데이터 db_song.UserTable:~3 rows (대략적) 내보내기
/*!40000 ALTER TABLE `UserTable` DISABLE KEYS */;
INSERT INTO `UserTable` (`UserName`, `NickName`, `UserID`, `UserPassword`, `UserEmail`, `IdCreatDatetime`) VALUES
	('클라우드', '클라우드', 'cd', 'cd', 'cd@.cd', '2023-01-03 09:15:06'),
	('백엔드', '백엔드', 'bk', 'bk', 'bk@.bk', '2023-01-03 09:17:41'),
	('프론트엔드', '프론트엔드', 'ft', 'ft', 'ft@.', '2023-01-03 09:20:26');
/*!40000 ALTER TABLE `UserTable` ENABLE KEYS */;

/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IFNULL(@OLD_FOREIGN_KEY_CHECKS, 1) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40111 SET SQL_NOTES=IFNULL(@OLD_SQL_NOTES, 1) */;
